{"version":3,"file":"three-pathfinding.js","sources":["../lib/THREE.quickhull.js","../index.js"],"sourcesContent":["/**\n\n  QuickHull\n  ---------\n\n  The MIT License\n\n  Copyright &copy; 2010-2014 three.js authors\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\n  THE SOFTWARE.\n\n\n    @author mark lundin / http://mark-lundin.com\n\n    This is a 3D implementation of the Quick Hull algorithm.\n    It is a fast way of computing a convex hull with average complexity\n    of O(n log(n)).\n    It uses depends on three.js and is supposed to create THREE.Geometry.\n\n    It's also very messy\n\n */\n\nexport const quickhull = (function(){\n\n\n  var faces     = [],\n    faceStack   = [],\n    i, NUM_POINTS, extremes,\n    max     = 0,\n    dcur, current, j, v0, v1, v2, v3,\n    N, D;\n\n  var ab, ac, ax,\n    suba, subb, normal,\n    diff, subaA, subaB, subC;\n\n  function reset(){\n\n    ab    = new THREE.Vector3(),\n    ac    = new THREE.Vector3(),\n    ax    = new THREE.Vector3(),\n    suba  = new THREE.Vector3(),\n    subb  = new THREE.Vector3(),\n    normal  = new THREE.Vector3(),\n    diff  = new THREE.Vector3(),\n    subaA = new THREE.Vector3(),\n    subaB = new THREE.Vector3(),\n    subC  = new THREE.Vector3();\n\n  }\n\n  //temporary vectors\n\n  function process( points ){\n\n    // Iterate through all the faces and remove\n    while( faceStack.length > 0  ){\n      cull( faceStack.shift(), points );\n    }\n  }\n\n\n  var norm = function(){\n\n    var ca = new THREE.Vector3(),\n      ba = new THREE.Vector3(),\n      N = new THREE.Vector3();\n\n    return function( a, b, c ){\n\n      ca.subVectors( c, a );\n      ba.subVectors( b, a );\n\n      N.crossVectors( ca, ba );\n\n      return N.normalize();\n    }\n\n  }();\n\n\n  function getNormal( face, points ){\n\n    if( face.normal !== undefined ) return face.normal;\n\n    var p0 = points[face[0]],\n      p1 = points[face[1]],\n      p2 = points[face[2]];\n\n    ab.subVectors( p1, p0 );\n    ac.subVectors( p2, p0 );\n    normal.crossVectors( ac, ab );\n    normal.normalize();\n\n    return face.normal = normal.clone();\n\n  }\n\n\n  function assignPoints( face, pointset, points ){\n\n    // ASSIGNING POINTS TO FACE\n    var p0 = points[face[0]],\n      dots = [], apex,\n      norm = getNormal( face, points );\n\n\n    // Sory all the points by there distance from the plane\n    pointset.sort( function( aItem, bItem ){\n\n\n      dots[aItem.x/3] = dots[aItem.x/3] !== undefined ? dots[aItem.x/3] : norm.dot( suba.subVectors( aItem, p0 ));\n      dots[bItem.x/3] = dots[bItem.x/3] !== undefined ? dots[bItem.x/3] : norm.dot( subb.subVectors( bItem, p0 ));\n\n      return dots[aItem.x/3] - dots[bItem.x/3] ;\n    });\n\n    //TODO :: Must be a faster way of finding and index in this array\n    var index = pointset.length;\n\n    if( index === 1 ) dots[pointset[0].x/3] = norm.dot( suba.subVectors( pointset[0], p0 ));\n    while( index-- > 0 && dots[pointset[index].x/3] > 0 )\n\n    var point;\n    if( index + 1 < pointset.length && dots[pointset[index+1].x/3] > 0 ){\n\n      face.visiblePoints  = pointset.splice( index + 1 );\n    }\n  }\n\n\n\n\n  function cull( face, points ){\n\n    var i = faces.length,\n      dot, visibleFace, currentFace,\n      visibleFaces = [face];\n\n    var apex = points.indexOf( face.visiblePoints.pop() );\n\n    // Iterate through all other faces...\n    while( i-- > 0 ){\n      currentFace = faces[i];\n      if( currentFace !== face ){\n        // ...and check if they're pointing in the same direction\n        dot = getNormal( currentFace, points ).dot( diff.subVectors( points[apex], points[currentFace[0]] ));\n        if( dot > 0 ){\n          visibleFaces.push( currentFace );\n        }\n      }\n    }\n\n    var index, neighbouringIndex, vertex;\n\n    // Determine Perimeter - Creates a bounded horizon\n\n    // 1. Pick an edge A out of all possible edges\n    // 2. Check if A is shared by any other face. a->b === b->a\n      // 2.1 for each edge in each triangle, isShared = ( f1.a == f2.a && f1.b == f2.b ) || ( f1.a == f2.b && f1.b == f2.a )\n    // 3. If not shared, then add to convex horizon set,\n        //pick an end point (N) of the current edge A and choose a new edge NA connected to A.\n        //Restart from 1.\n    // 4. If A is shared, it is not an horizon edge, therefore flag both faces that share this edge as candidates for culling\n    // 5. If candidate geometry is a degenrate triangle (ie. the tangent space normal cannot be computed) then remove that triangle from all further processing\n\n\n    var j = i = visibleFaces.length;\n    var isDistinct = false,\n      hasOneVisibleFace = i === 1,\n      cull = [],\n      perimeter = [],\n      edgeIndex = 0, compareFace, nextIndex,\n      a, b;\n\n    var allPoints = [];\n    var originFace = [visibleFaces[0][0], visibleFaces[0][1], visibleFaces[0][1], visibleFaces[0][2], visibleFaces[0][2], visibleFaces[0][0]];\n\n\n    if( visibleFaces.length === 1 ){\n      currentFace = visibleFaces[0];\n\n      perimeter = [currentFace[0], currentFace[1], currentFace[1], currentFace[2], currentFace[2], currentFace[0]];\n      // remove visible face from list of faces\n      if( faceStack.indexOf( currentFace ) > -1 ){\n        faceStack.splice( faceStack.indexOf( currentFace ), 1 );\n      }\n\n\n      if( currentFace.visiblePoints ) allPoints = allPoints.concat( currentFace.visiblePoints );\n      faces.splice( faces.indexOf( currentFace ), 1 );\n\n    }else{\n\n      while( i-- > 0  ){  // for each visible face\n\n        currentFace = visibleFaces[i];\n\n        // remove visible face from list of faces\n        if( faceStack.indexOf( currentFace ) > -1 ){\n          faceStack.splice( faceStack.indexOf( currentFace ), 1 );\n        }\n\n        if( currentFace.visiblePoints ) allPoints = allPoints.concat( currentFace.visiblePoints );\n        faces.splice( faces.indexOf( currentFace ), 1 );\n\n\n        var isSharedEdge;\n        cEdgeIndex = 0;\n\n        while( cEdgeIndex < 3 ){ // Iterate through it's edges\n\n          isSharedEdge = false;\n          j = visibleFaces.length;\n          a = currentFace[cEdgeIndex]\n          b = currentFace[(cEdgeIndex+1)%3];\n\n\n          while( j-- > 0 && !isSharedEdge ){ // find another visible faces\n\n            compareFace = visibleFaces[j];\n            edgeIndex = 0;\n\n            // isSharedEdge = compareFace == currentFace;\n            if( compareFace !== currentFace ){\n\n              while( edgeIndex < 3 && !isSharedEdge ){ //Check all it's indices\n\n                nextIndex = ( edgeIndex + 1 );\n                isSharedEdge = ( compareFace[edgeIndex] === a && compareFace[nextIndex%3] === b ) ||\n                         ( compareFace[edgeIndex] === b && compareFace[nextIndex%3] === a );\n\n                edgeIndex++;\n              }\n            }\n          }\n\n          if( !isSharedEdge || hasOneVisibleFace ){\n            perimeter.push( a );\n            perimeter.push( b );\n          }\n\n          cEdgeIndex++;\n        }\n      }\n    }\n\n    // create new face for all pairs around edge\n    i = 0;\n    var l = perimeter.length/2;\n    var f;\n\n    while( i < l ){\n      f = [ perimeter[i*2+1], apex, perimeter[i*2] ];\n      assignPoints( f, allPoints, points );\n      faces.push( f )\n      if( f.visiblePoints !== undefined  )faceStack.push( f );\n      i++;\n    }\n\n  }\n\n  var distSqPointSegment = function(){\n\n    var ab = new THREE.Vector3(),\n      ac = new THREE.Vector3(),\n      bc = new THREE.Vector3();\n\n    return function( a, b, c ){\n\n        ab.subVectors( b, a );\n        ac.subVectors( c, a );\n        bc.subVectors( c, b );\n\n        var e = ac.dot(ab);\n        if (e < 0.0) return ac.dot( ac );\n        var f = ab.dot( ab );\n        if (e >= f) return bc.dot(  bc );\n        return ac.dot( ac ) - e * e / f;\n\n      }\n\n  }();\n\n\n\n\n\n  return function( geometry ){\n\n    reset();\n\n\n    points    = geometry.vertices;\n    faces     = [],\n    faceStack   = [],\n    i       = NUM_POINTS = points.length,\n    extremes  = points.slice( 0, 6 ),\n    max     = 0;\n\n\n\n    /*\n     *  FIND EXTREMETIES\n     */\n    while( i-- > 0 ){\n      if( points[i].x < extremes[0].x ) extremes[0] = points[i];\n      if( points[i].x > extremes[1].x ) extremes[1] = points[i];\n\n      if( points[i].y < extremes[2].y ) extremes[2] = points[i];\n      if( points[i].y < extremes[3].y ) extremes[3] = points[i];\n\n      if( points[i].z < extremes[4].z ) extremes[4] = points[i];\n      if( points[i].z < extremes[5].z ) extremes[5] = points[i];\n    }\n\n\n    /*\n     *  Find the longest line between the extremeties\n     */\n\n    j = i = 6;\n    while( i-- > 0 ){\n      j = i - 1;\n      while( j-- > 0 ){\n          if( max < (dcur = extremes[i].distanceToSquared( extremes[j] )) ){\n        max = dcur;\n        v0 = extremes[ i ];\n        v1 = extremes[ j ];\n\n          }\n        }\n      }\n\n\n      // 3. Find the most distant point to the line segment, this creates a plane\n      i = 6;\n      max = 0;\n    while( i-- > 0 ){\n      dcur = distSqPointSegment( v0, v1, extremes[i]);\n      if( max < dcur ){\n        max = dcur;\n            v2 = extremes[ i ];\n          }\n    }\n\n\n      // 4. Find the most distant point to the plane.\n\n      N = norm(v0, v1, v2);\n      D = N.dot( v0 );\n\n\n      max = 0;\n      i = NUM_POINTS;\n      while( i-- > 0 ){\n        dcur = Math.abs( points[i].dot( N ) - D );\n          if( max < dcur ){\n            max = dcur;\n            v3 = points[i];\n      }\n      }\n\n\n\n      var v0Index = points.indexOf( v0 ),\n      v1Index = points.indexOf( v1 ),\n      v2Index = points.indexOf( v2 ),\n      v3Index = points.indexOf( v3 );\n\n\n    //  We now have a tetrahedron as the base geometry.\n    //  Now we must subdivide the\n\n      var tetrahedron =[\n        [ v2Index, v1Index, v0Index ],\n        [ v1Index, v3Index, v0Index ],\n        [ v2Index, v3Index, v1Index ],\n        [ v0Index, v3Index, v2Index ],\n    ];\n\n\n\n    subaA.subVectors( v1, v0 ).normalize();\n    subaB.subVectors( v2, v0 ).normalize();\n    subC.subVectors ( v3, v0 ).normalize();\n    var sign  = subC.dot( new THREE.Vector3().crossVectors( subaB, subaA ));\n\n\n    // Reverse the winding if negative sign\n    if( sign < 0 ){\n      tetrahedron[0].reverse();\n      tetrahedron[1].reverse();\n      tetrahedron[2].reverse();\n      tetrahedron[3].reverse();\n    }\n\n\n    //One for each face of the pyramid\n    var pointsCloned = points.slice();\n    pointsCloned.splice( pointsCloned.indexOf( v0 ), 1 );\n    pointsCloned.splice( pointsCloned.indexOf( v1 ), 1 );\n    pointsCloned.splice( pointsCloned.indexOf( v2 ), 1 );\n    pointsCloned.splice( pointsCloned.indexOf( v3 ), 1 );\n\n\n    var i = tetrahedron.length;\n    while( i-- > 0 ){\n      assignPoints( tetrahedron[i], pointsCloned, points );\n      if( tetrahedron[i].visiblePoints !== undefined ){\n        faceStack.push( tetrahedron[i] );\n      }\n      faces.push( tetrahedron[i] );\n    }\n\n    process( points );\n\n\n    //  Assign to our geometry object\n\n    var ll = faces.length;\n    while( ll-- > 0 ){\n      geometry.faces[ll] = new THREE.Face3( faces[ll][2], faces[ll][1], faces[ll][0], faces[ll].normal )\n    }\n\n    geometry.normalsNeedUpdate = true;\n\n    return geometry;\n\n  }\n\n}())\n","import * as CANNON from 'cannon';\nimport { quickhull } from './lib/THREE.quickhull';\n\nvar PI_2 = Math.PI / 2;\n\nvar Type = {\n  BOX: 'Box',\n  CYLINDER: 'Cylinder',\n  SPHERE: 'Sphere',\n  HULL: 'ConvexPolyhedron',\n  MESH: 'Trimesh'\n};\n\n/**\n * Given a THREE.Object3D instance, creates a corresponding CANNON shape.\n * @param  {THREE.Object3D} object\n * @return {CANNON.Shape}\n */\nexport const threeToCannon = function (object, options) {\n  options = options || {};\n\n  var geometry;\n\n  if (options.type === Type.BOX) {\n    return createBoundingBoxShape(object);\n  } else if (options.type === Type.CYLINDER) {\n    return createBoundingCylinderShape(object, options);\n  } else if (options.type === Type.SPHERE) {\n    return createBoundingSphereShape(object, options);\n  } else if (options.type === Type.HULL) {\n    return createConvexPolyhedron(object);\n  } else if (options.type === Type.MESH) {\n    geometry = getGeometry(object);\n    return geometry ? createTrimeshShape(geometry) : null;\n  } else if (options.type) {\n    throw new Error('[CANNON.threeToCannon] Invalid type \"%s\".', options.type);\n  }\n\n  geometry = getGeometry(object);\n  if (!geometry) return null;\n\n  var type = geometry.metadata\n    ? geometry.metadata.type\n    : geometry.type;\n\n  switch (type) {\n    case 'BoxGeometry':\n    case 'BoxBufferGeometry':\n      return createBoxShape(geometry);\n    case 'CylinderGeometry':\n    case 'CylinderBufferGeometry':\n      return createCylinderShape(geometry);\n    case 'PlaneGeometry':\n    case 'PlaneBufferGeometry':\n      return createPlaneShape(geometry);\n    case 'SphereGeometry':\n    case 'SphereBufferGeometry':\n      return createSphereShape(geometry);\n    case 'TubeGeometry':\n    case 'Geometry':\n    case 'BufferGeometry':\n      return createBoundingBoxShape(object);\n    default:\n      console.warn('Unrecognized geometry: \"%s\". Using bounding box as shape.', geometry.type);\n      return createBoxShape(geometry);\n  }\n};\n\nthreeToCannon.Type = Type;\n\n/******************************************************************************\n * Shape construction\n */\n\n /**\n  * @param  {THREE.Geometry} geometry\n  * @return {CANNON.Shape}\n  */\n function createBoxShape (geometry) {\n   var vertices = getVertices(geometry);\n\n   if (!vertices.length) return null;\n\n   geometry.computeBoundingBox();\n   var box = geometry.boundingBox;\n   return new CANNON.Box(new CANNON.Vec3(\n     (box.max.x - box.min.x) / 2,\n     (box.max.y - box.min.y) / 2,\n     (box.max.z - box.min.z) / 2\n   ));\n }\n\n/**\n * Bounding box needs to be computed with the entire mesh, not just geometry.\n * @param  {THREE.Object3D} mesh\n * @return {CANNON.Shape}\n */\nfunction createBoundingBoxShape (object) {\n  var shape, localPosition,\n      box = new THREE.Box3();\n\n  var clone = object.clone();\n  clone.quaternion.set(0, 0, 0, 1);\n  clone.updateMatrixWorld();\n\n  box.setFromObject(clone);\n\n  if (!isFinite(box.min.lengthSq())) return null;\n\n  shape = new CANNON.Box(new CANNON.Vec3(\n    (box.max.x - box.min.x) / 2,\n    (box.max.y - box.min.y) / 2,\n    (box.max.z - box.min.z) / 2\n  ));\n\n  localPosition = box.translate(clone.position.negate()).getCenter(new THREE.Vector3());\n  if (localPosition.lengthSq()) {\n    shape.offset = localPosition;\n  }\n\n  return shape;\n}\n\n/**\n * Computes 3D convex hull as a CANNON.ConvexPolyhedron.\n * @param  {THREE.Object3D} mesh\n * @return {CANNON.Shape}\n */\nfunction createConvexPolyhedron (object) {\n  var i, vertices, faces, hull,\n      eps = 1e-4,\n      geometry = getGeometry(object);\n\n  if (!geometry || !geometry.vertices.length) return null;\n\n  // Perturb.\n  for (i = 0; i < geometry.vertices.length; i++) {\n    geometry.vertices[i].x += (Math.random() - 0.5) * eps;\n    geometry.vertices[i].y += (Math.random() - 0.5) * eps;\n    geometry.vertices[i].z += (Math.random() - 0.5) * eps;\n  }\n\n  // Compute the 3D convex hull.\n  hull = quickhull(geometry);\n\n  // Convert from THREE.Vector3 to CANNON.Vec3.\n  vertices = new Array(hull.vertices.length);\n  for (i = 0; i < hull.vertices.length; i++) {\n    vertices[i] = new CANNON.Vec3(hull.vertices[i].x, hull.vertices[i].y, hull.vertices[i].z);\n  }\n\n  // Convert from THREE.Face to Array<number>.\n  faces = new Array(hull.faces.length);\n  for (i = 0; i < hull.faces.length; i++) {\n    faces[i] = [hull.faces[i].a, hull.faces[i].b, hull.faces[i].c];\n  }\n\n  return new CANNON.ConvexPolyhedron(vertices, faces);\n}\n\n/**\n * @param  {THREE.Geometry} geometry\n * @return {CANNON.Shape}\n */\nfunction createCylinderShape (geometry) {\n  var shape,\n      params = geometry.metadata\n        ? geometry.metadata.parameters\n        : geometry.parameters;\n  shape = new CANNON.Cylinder(\n    params.radiusTop,\n    params.radiusBottom,\n    params.height,\n    params.radialSegments\n  );\n\n  // Include metadata for serialization.\n  shape._type = CANNON.Shape.types.CYLINDER; // Patch schteppe/cannon.js#329.\n  shape.radiusTop = params.radiusTop;\n  shape.radiusBottom = params.radiusBottom;\n  shape.height = params.height;\n  shape.numSegments = params.radialSegments;\n\n  shape.orientation = new CANNON.Quaternion();\n  shape.orientation.setFromEuler(THREE.Math.degToRad(90), 0, 0, 'XYZ').normalize();\n  return shape;\n}\n\n/**\n * @param  {THREE.Object3D} object\n * @return {CANNON.Shape}\n */\nfunction createBoundingCylinderShape (object, options) {\n  var shape, height, radius,\n      box = new THREE.Box3(),\n      axes = ['x', 'y', 'z'],\n      majorAxis = options.cylinderAxis || 'y',\n      minorAxes = axes.splice(axes.indexOf(majorAxis), 1) && axes;\n\n  box.setFromObject(object);\n\n  if (!isFinite(box.min.lengthSq())) return null;\n\n  // Compute cylinder dimensions.\n  height = box.max[majorAxis] - box.min[majorAxis];\n  radius = 0.5 * Math.max(\n    box.max[minorAxes[0]] - box.min[minorAxes[0]],\n    box.max[minorAxes[1]] - box.min[minorAxes[1]]\n  );\n\n  // Create shape.\n  shape = new CANNON.Cylinder(radius, radius, height, 12);\n\n  // Include metadata for serialization.\n  shape._type = CANNON.Shape.types.CYLINDER; // Patch schteppe/cannon.js#329.\n  shape.radiusTop = radius;\n  shape.radiusBottom = radius;\n  shape.height = height;\n  shape.numSegments = 12;\n\n  shape.orientation = new CANNON.Quaternion();\n  shape.orientation.setFromEuler(\n    majorAxis === 'y' ? PI_2 : 0,\n    majorAxis === 'z' ? PI_2 : 0,\n    0,\n    'XYZ'\n  ).normalize();\n  return shape;\n}\n\n/**\n * @param  {THREE.Geometry} geometry\n * @return {CANNON.Shape}\n */\nfunction createPlaneShape (geometry) {\n  geometry.computeBoundingBox();\n  var box = geometry.boundingBox;\n  return new CANNON.Box(new CANNON.Vec3(\n    (box.max.x - box.min.x) / 2 || 0.1,\n    (box.max.y - box.min.y) / 2 || 0.1,\n    (box.max.z - box.min.z) / 2 || 0.1\n  ));\n}\n\n/**\n * @param  {THREE.Geometry} geometry\n * @return {CANNON.Shape}\n */\nfunction createSphereShape (geometry) {\n  var params = geometry.metadata\n    ? geometry.metadata.parameters\n    : geometry.parameters;\n  return new CANNON.Sphere(params.radius);\n}\n\n/**\n * @param  {THREE.Object3D} object\n * @return {CANNON.Shape}\n */\nfunction createBoundingSphereShape (object, options) {\n  if (options.sphereRadius) {\n    return new CANNON.Sphere(options.sphereRadius);\n  }\n  var geometry = getGeometry(object);\n  if (!geometry) return null;\n  geometry.computeBoundingSphere();\n  return new CANNON.Sphere(geometry.boundingSphere.radius);\n}\n\n/**\n * @param  {THREE.Geometry} geometry\n * @return {CANNON.Shape}\n */\nfunction createTrimeshShape (geometry) {\n  var indices,\n      vertices = getVertices(geometry);\n\n  if (!vertices.length) return null;\n\n  indices = Object.keys(vertices).map(Number);\n  return new CANNON.Trimesh(vertices, indices);\n}\n\n/******************************************************************************\n * Utils\n */\n\n/**\n * Returns a single geometry for the given object. If the object is compound,\n * its geometries are automatically merged.\n * @param {THREE.Object3D} object\n * @return {THREE.Geometry}\n */\nfunction getGeometry (object) {\n  var matrix, mesh,\n      meshes = getMeshes(object),\n      tmp = new THREE.Geometry(),\n      combined = new THREE.Geometry();\n\n  if (meshes.length === 0) return null;\n\n  // Apply scale  â€“ it can't easily be applied to a CANNON.Shape later.\n  if (meshes.length === 1) {\n    var position = new THREE.Vector3(),\n        quaternion = new THREE.Quaternion(),\n        scale = new THREE.Vector3();\n    if (meshes[0].geometry.isBufferGeometry) {\n      if (meshes[0].geometry.attributes.position\n          && meshes[0].geometry.attributes.position.itemSize > 2) {\n        tmp.fromBufferGeometry(meshes[0].geometry);\n      }\n    } else {\n      tmp = meshes[0].geometry.clone();\n    }\n    tmp.metadata = meshes[0].geometry.metadata;\n    meshes[0].updateMatrixWorld();\n    meshes[0].matrixWorld.decompose(position, quaternion, scale);\n    return tmp.scale(scale.x, scale.y, scale.z);\n  }\n\n  // Recursively merge geometry, preserving local transforms.\n  while ((mesh = meshes.pop())) {\n    mesh.updateMatrixWorld();\n    if (mesh.geometry.isBufferGeometry) {\n      if (mesh.geometry.attributes.position\n          && mesh.geometry.attributes.position.itemSize > 2) {\n        var tmpGeom = new THREE.Geometry();\n        tmpGeom.fromBufferGeometry(mesh.geometry);\n        combined.merge(tmpGeom, mesh.matrixWorld);\n        tmpGeom.dispose();\n      }\n    } else {\n      combined.merge(mesh.geometry, mesh.matrixWorld);\n    }\n  }\n\n  matrix = new THREE.Matrix4();\n  matrix.scale(object.scale);\n  combined.applyMatrix(matrix);\n  return combined;\n}\n\n/**\n * @param  {THREE.Geometry} geometry\n * @return {Array<number>}\n */\nfunction getVertices (geometry) {\n  if (!geometry.attributes) {\n    geometry = new THREE.BufferGeometry().fromGeometry(geometry);\n  }\n  return (geometry.attributes.position || {}).array || [];\n}\n\n/**\n * Returns a flat array of THREE.Mesh instances from the given object. If\n * nested transformations are found, they are applied to child meshes\n * as mesh.userData.matrix, so that each mesh has its position/rotation/scale\n * independently of all of its parents except the top-level object.\n * @param  {THREE.Object3D} object\n * @return {Array<THREE.Mesh>}\n */\nfunction getMeshes (object) {\n  var meshes = [];\n  object.traverse(function (o) {\n    if (o.type === 'Mesh') {\n      meshes.push(o);\n    }\n  });\n  return meshes;\n}\n"],"names":["quickhull","NUM_POINTS","extremes","dcur","j","v0","v1","v2","v3","N","D","ab","ac","suba","subb","normal","diff","subaA","subaB","subC","faces","faceStack","max","norm","ca","THREE","Vector3","ba","a","b","c","subVectors","crossVectors","normalize","getNormal","face","points","undefined","p0","p2","clone","assignPoints","pointset","dots","sort","aItem","bItem","x","dot","index","length","visiblePoints","splice","cull","currentFace","i","visibleFaces","apex","indexOf","pop","push","compareFace","nextIndex","hasOneVisibleFace","perimeter","edgeIndex","allPoints","concat","isSharedEdge","cEdgeIndex","f","l","distSqPointSegment","bc","e","geometry","vertices","slice","y","z","distanceToSquared","Math","abs","v0Index","v1Index","v2Index","v3Index","tetrahedron","reverse","pointsCloned","shift","process","ll","Face3","normalsNeedUpdate","PI_2","PI","Type","BOX","CYLINDER","SPHERE","HULL","MESH","threeToCannon","object","options","type","createBoundingBoxShape","shape","height","radius","box","Box3","axes","majorAxis","cylinderAxis","minorAxes","setFromObject","isFinite","min","lengthSq","CANNON.Cylinder","_type","CANNON.Shape","types","radiusTop","radiusBottom","numSegments","orientation","CANNON.Quaternion","setFromEuler","createBoundingCylinderShape","sphereRadius","CANNON.Sphere","getGeometry","computeBoundingSphere","boundingSphere","createBoundingSphereShape","hull","random","Array","CANNON.Vec3","CANNON.ConvexPolyhedron","createConvexPolyhedron","indices","getVertices","Object","keys","map","Number","CANNON.Trimesh","createTrimeshShape","Error","metadata","createBoxShape","params","parameters","radialSegments","degToRad","createCylinderShape","computeBoundingBox","boundingBox","CANNON.Box","createPlaneShape","createSphereShape","console","warn","localPosition","quaternion","set","updateMatrixWorld","translate","position","negate","getCenter","offset","matrix","mesh","meshes","traverse","o","getMeshes","tmp","Geometry","combined","Quaternion","scale","isBufferGeometry","attributes","itemSize","fromBufferGeometry","matrixWorld","decompose","tmpGeom","merge","dispose","Matrix4","applyMatrix","BufferGeometry","fromGeometry","array"],"mappings":"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"}